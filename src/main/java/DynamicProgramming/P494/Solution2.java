package DynamicProgramming.P494;

/*
官方题解：方法三，动态规划+空间优化
思路：背包问题太难顶了，想仔细看就去看看官方题解怎么说的吧

时间复杂度：O(N*sum)，N为数组长度，sum为初始数组和      打败73.77%
空间复杂度：O(sum)                                   打败17.56%
*/

class Solution2 {
	public int findTargetSumWays(int[] nums, int S) {
		//因为和可能为负，而数组下标不能为负，且数组和不超过1000，所以为所有原本“和”+1000，使之能正确作为数组下标
		int[] dp = new int[2001];
		//初始化时代表第一行，即第一个数nums[0]能组成的和，故将以nums[0]+1000的dp值赋为1
		dp[nums[0]+1000] = 1;
		//这里用+=而不是=，是因为nums[0]可能为0：
		//  1.若nums[0]不为0，直接在数组初始0的基础上+1，表示nums[0]前面加“-”得到的和有几种
		//  2.若nums[0]为0，因为0前面加“+”还是“-”都是0，一样的结果，则dp值应为2，可以视为在上一行代码的基础上再+1
		//综上，用+=可以满足所有的情况，而=不能
		dp[-nums[0]+1000] += 1;

		for(int i=1; i<nums.length; i++){
			//使用了空间优化，dp[]数组表示dp[i-1][]，next[]数组表示dp[i][]。
			int[] next = new int[2001];
			for(int sum=-1000; sum<=1000; sum++){
				//满足if条件才有计算的必要，否则dp[sum+1000]==0，说明根本没有和为sum的情况，无需往后递推
				if(dp[sum+1000]>0){
					//因为有不同情况下的和(sum+nums[i]/sum-nums[i])可能是一样的，所以不能简单的用“=”，要用“+=”
					//1.第一次用到这个公式时，数组初始化的0还未被修改，就是0+dp[sum+1000]，“+=”效果和“=”一样
					//2.后面可能有(sum+nums[i]/sum-nums[i])与前面某次的(sum+nums[i]/sum-nums[i])是相同的，此时数组中对应下标处已经有值了，不能
					//  再简单的用“=”，而应该在已有基础上“+”
					//综上，用“+=”是比较合适的
					next[sum+nums[i]+1000] += dp[sum+1000];
					next[sum-nums[i]+1000] += dp[sum+1000];
				}
			}
			dp = next;
		}

		return Math.abs(S)>1000 ? 0 : dp[S+1000];
	}
}
