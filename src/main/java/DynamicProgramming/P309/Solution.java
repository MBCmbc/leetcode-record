package DynamicProgramming.P309;

/*
官方题解：动态规划+空间优化

思路：
对于股票问题，一种常用的方法是将「买入」和「卖出」分开进行考虑：「买入」为负收益，而「卖出」为正收益。

用f表示每天“结束”之后的「累计最大收益」，则每一天“结束”之后我们会有以下三种状态：
    1. 我们目前持有一支股票，对应的「累计最大收益」记为f0；
    2. 我们目前手中没有股票，且处于冷冻期，对应的「累计最大收益」记为f1；
    3. 我们目前手中没有股票，且不处于冷冻期，对应的「累计最大收益」记为f2；
据此分析可以得到三个状态转移方程，具体见代码中的注释。

边界条件：
    对于三种情况在第一天的值，可分别初始化为：
        1. -prices[0]，（买入一支股票）
        2. 0，（不持有任何股票，收益为0）
        3. 0，（不持有任何股票，收益为0）

返回结果：
    由于追求最大收益，所以最后一天结束后还持有股票是没有任何意义的，故返回Math.max(f1,f2)即可。


时间复杂度：O(N)        打败99.59%
空间复杂度：O(1)        打败76.01%
*/

class Solution {
	public int maxProfit(int[] prices) {
		int n = prices.length;
		//数组为空，无收益。
		if (n == 0) return 0;

		//初始化边界条件
		int f0 = -prices[0];
		int f1 = 0;
		int f2 = 0;

		//状态转移
		for(int i=1; i<n; i++){
			//今天“结束后”持有股票，则前一天“结束后”只能有两种情况：
			//1.前一天“结束后”持有股票，今天不做任何操作。收益无变化
			//2.前一天“结束后”未持有股票且不处于冷冻期，今天买入股票，为负收益。
			int newf0 = Math.max(f0, f2-prices[i]);
			//今天“结束后”不持有股票且处于冷冻期，则只能是：前一天“结束后”持有股票，今天将其卖出，得到正收益。
			int newf1 = f0 + prices[i];
			//今天“结束后”不持有股票且不处于冷冻期，则前一天“结束后”只能有两种情况：
			//1.前一天“结束后”不持有股票且处于冷冻期，今天不做任何操作，今天“结束后”冷冻期也就结束了。收益无变化
			//2..前一天“结束后”不持有股票且不处于冷冻期，且今天不做任何操作。收益无变化
			int newf2 = Math.max(f1, f2);

			//值更新
			f0 = newf0;
			f1 = newf1;
			f2 = newf2;
		}

		//由于追求最大收益，所以最后一天结束后还持有股票（f0）是没有任何意义的，故返回Math.max(f1,f2)即可。
		return Math.max(f1,f2);
	}
}
