package DynamicProgramming.P62;

/*
https://leetcode-cn.com/problems/unique-paths/solution/dong-tai-gui-hua-by-powcai-2/
优化2：空间复杂度O(n)。
在下面注释中动态规划的基础上改进。因为状态转移方程为grid[i][j] = grid[i-1][j] + grid[i][j-1]，
所以我们只要确保能拿到grid[i-1][j]和grid[i][j-1]即可。

可以只用一个一维数组curr[]迭代地表示grid中的每一行，因为路径数=到达左边网格的路径数+到达上边网格的路径数，
所以从一维数组的第二个格子到最后一个格子遍历，读数据自然可以拿到当前格子左边格子代表的路径数，
而当前格子上边格子所代表的路径数就是自己的值（因为此时还没更新自己的值，仍然表示上一行的值）。

所以状态转移方程为curr[j] = curr[j] + curr[j-1]。(不理解的话画个表格看一下就知道了)
*/


/*
自己的解法，动态规划。

思路：用一个二维数组grid[][]表示网格中到达每个点可有的不同路径数。利用动态规划遍历最终得到要到达右下角有多少不同的路径。
状态转移方程：因为每一步都只能向右或者向下走，所以对于网格的第一行中的元素，只有从左到右一种走法；网格第一列元素同理。
对于其他普通网格，则路径数=到达左边网格的路径数+到达上边网格的路径数。即，grid[i][j] = grid[i-1][j] + grid[i][j-1]。

时间复杂度：O(m*n);
空间复杂度：O(m*n);
*/


import java.util.Arrays;

class Solution {
	public int uniquePaths(int m, int n) {
		//定义一维数组表示当前行
		int[] curr = new int[n];
		//表格第一行的值全为1
		Arrays.fill(curr,1);

		//注意，行和列的循环都从1开始，因为第一行已经赋值过；而第一列都为1，无需改变。
		for(int i=1; i<m; i++){
			for(int j=1; j<n; j++){
				//状态转移方程，到达当前格的路径数=到达左边格子的路径数+到达上边格子的路径数。
				//这里只用了一维数组表示，当前格子左边的值仍表示左边格子的路径数，当前格子自己的旧值则表示当前格子上边格子的路径数。
				//所以当前格子的新值可以用(当前格子的旧值+左边格子的值)更新。
				curr[j] += curr[j-1];
			}
		}

		//返回到达右下角格子的路径数。
		return curr[n-1];
	}
}