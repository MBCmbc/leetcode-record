package Array.P41;

/*
官方题解，方法一。

设数组长为n，存在以下两种情况：
    1. 数组中，[1,n]中n个数并未全部出现，结果为未出现数中的最小者；
    2. 数组内容恰好为[1,n]中n个数，则结果为n+1。

则可以根据以下三步找到结果：
    1. 遍历数组将所有小于等于0的数都赋值为n+1，以便后面可以用负号打标记；
    2. 遍历数组打标记,若出现[1,n]之间的数num，将对应(num-1)下标的数标记为负，表示出现过。（-1是为了符合数组下标要求）；
    3. 遍历数组，若某个数为正，说明未被标记，根据第二步规则，该数下标+1即为未出现过的最小正整数。若遍历完发现全为负，则说明[1,n]都出现过，结果为n+1。

时间复杂度：O(N)    打败88.10%
空间复杂度：O(1)    打败72.25%
*/

class Solution1 {
	public int firstMissingPositive(int[] nums) {
		int n = nums.length;
		//第一步，遍历数组将所有小于等于0的数都赋值为n+1，以便后面可以用负号打标记。
		for(int i=0; i<n; i++){
			if(nums[i] <= 0) nums[i] = n+1;
		}

		//第二步,打标记,若出现[1,n]之间的数num，将对应(num-1)下标的数标记为负，表示出现过。（-1是为了符合数组下标要求）
		for(int i=0; i<n; i++){
			//因为可能已经被打标记为负，所以用绝对值来判断。
			int num = Math.abs(nums[i]);
			if(num <=n){
				//符合打标记的要求，将对应下表的数标记为负，说明num出现过。
				nums[num-1] = -Math.abs(nums[num-1]);
			}
		}

		//第三步，若某个数为正，说明未被标记，根据第二步规则，该数下标+1即为未出现过的最小正整数
		for(int i=0; i<n; i++){
			if(nums[i] > 0) return i+1;
		}

        /*
            设数组长为n，存在以下两种情况：
            1. 数组中，[1,n]中n个数并未全部出现，结果为未出现数中的最小者；
            2. 数组内容恰好为[1,n]中n个数，则结果为n+1。
        */
		//若到此步没有返回，说明[1,n]都出现过，则未出现过的最小正整数必为n+1
		return n+1;
	}
}
