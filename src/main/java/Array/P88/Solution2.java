package Array.P88;

/*
官方题解：方法三
思路：首先，两个数组都是有序的。其次，因为nums1的后半部分是冗余空间，元素都是0，就算做修改也对前面的内容没有影响，
所以可以对nums1和nums2两个数组的有效元素，按从后向前的方向遍历，根据遍历到元素的大小从后向前填入nums1的空闲位置。
就算后面填充到了nums1的有效元素位置，该位置的元素之前也一定已经遍历过了，没有影响。

时间复杂度：从后向前对“合并后的nums1”进行了填充操作，故为O(m+n)。       执行用时：打败100%
空间复杂度：只用了常数量级的额外空间，故为O(1)。                        内存消耗：打败5.06%
*/


class Solution2 {
	public void merge(int[] nums1, int m, int[] nums2, int n) {
		//指向nums1末尾的指针
		int p1 = m-1;
		//指向nums2末尾的指针
		int p2 = n-1;
		//指向“合并后nums1”末尾的指针
		int p = m+n-1;

		//从后向前遍历，倒着往“合并后的num1”中添加元素。
		while((p1>=0) && (p2>=0)){
			nums1[p--] = nums1[p1] > nums2[p2] ? nums1[p1--] : nums2[p2--];
		}

		//nums1和nums2可能不一样长，上述while循环结束后可能有其中一个数组还没遍历完。
		//情况1：若nums1还有剩余，则无需任何额外操作，因为剩下的元素已经是有序的并且在nums1的头部了。
		//情况2：若nums2还有剩余，将内容拷贝进num1的前半部分即可。
		System.arraycopy(nums2, 0, nums1, 0, p2+1);
		//p2+1这个值很巧妙，若while循环完nums2有剩余元素，则p2>0，p2+1就代表剩余元素的长度
		//若若while循环完nums1有剩余元素，nums2没有剩余元素，则p2=-1，p2+1=0，也就是拷贝长度为0，相当于没有拷贝，也对应了情况1需要的操作。
	}
}